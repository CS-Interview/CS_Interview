# 면접 질문

---

---

## 1. Big O, Big theta, Big Omega에 대해서 설명해 주세요.

- Big O : 시간의 상한 (최악의 경우), 해당 알고리즘은 big-O보다 더 오래 걸릴 수 없다.
- Big theta : 평균적인 경우, 딱 맞는 수행 시간, big-O와 big-Omega를 하나로 합쳐 표현한 것과 같다.
- Big Omega : 시간의 하한 (최선의 경우), 해당 알고리즘은 big-Omega보다 더 빠를 수 없다.

## 2. 자료구조란 무엇이고, 시간복잡도란 무엇인가요?

- 효율적인 프로그램을 작성할 때 가장 우선적인 고려사항은 저장공간의 효율성과 실행시간의 신속성이다. 자료구조는 프로그램에서 사용하기 위한 자료를 기억장치의 공간내에 저장하는 방법과 저장된 그룹 내에 존재하는 자료 간의 관계, 처리방법 등을 연구하여 분석하는 것을 말한다.
- 시간 복잡도란 특정 알고리즘이 어떤 문제를 해결하는데 걸리는 시간을 의미합니다. 같은 결과를 가져오는 프로그래밍 소스도 어떻게 작성하느냐에 따라 걸리는 시간이 달라질 수 있
습니다.

## 3. 스택(Stack)과 큐(Queue)의 차이점

- 스택(Stack)은 LIFO(Last In First Out), 즉 나중에 들어간 원소가 나중에 나오는 차곡차곡 쌓이는 구조입니다. 먼저 스택에 들어가게 된 원소는 맨바닥에 깔리게 되고, 그렇기 때문에 늦게 들어간 원소들은 그 위에 쌓여 호출 시 가장 위에 있는 원소가 호출되는 구조인 반면, 큐(Queue)는 FIFO(First In First Out), 즉 먼저 들어간 원소가 먼저 나오는 구조로서 이 점이 스택과 큐의 가장 대표적인 차이점입니다.

## 3-1. Java에서 (잘못된 상속 구조 and 컬렉션으로 쓰이지 않는 자료구조)가 있습니다. 혹시 어떤 것인지 알고 계십니까?

- Stack (Vector를 상속하고 있음)입니다. @Deprecated되어있지 않을 뿐, 가급적으로 쓰면 안되는 컬렉션으로 알고 있습니다.

## 3-2. 그렇다면 왜 잘못 작성되어있는지에 대해서 설명해주실 수 있을까요?

- 먼저 Stack이 쓰면 안되는 컬렉션인 이유는 Vector를 상속받고 있기 때문입니다. Vector의 모든 get()과 put()은 synchronized(동기화) 키워드가 붙어있습니다. 이건 특정 상황에서 성능을 꽤 저하시킬 수도 있습니다. 


## 3-3. 어떤 상황에서 좋지 않을까요? 

- 단순하게만 생각해도 Vector에 Iterator를 붙여 순차적으로 item을 탐색하기만 해도 원소 탐색 시마다 get() 메서드의 실행을 위해 계속 lock을 걸고 닫고 하므로 locking에 대한 엄청난 오버헤드가 발생하게 됩니다. 그렇기에 효율적인 Thread-safe 컬렉션이 될 수 없다.

## 3-4. Stack 대신에 적절하게 사용할만한 자료구조는 무엇이라고 생각하시나요?

- ArrayList, Deque

## 4. 배열(Array)와 LinkedList의 차이점에 대해서 설명해 주세요.

- 배열(Array)은 요소들이 인접한 메모리 위치에 연이어 저장되어 요소들을 인덱스를 통해 직접 접근할 수 있기 때문에 Random Access를 지원한다. 이때의 시간 복잡도는 O(1)이다. 하지만 요소의 삭제와 삽입의 경우 배열은 추가되거나 삭제되는 데이터 위치 이후에 있는 모든 데이터들을 한 칸씩 미뤄야 하므로 시간복잡도는 O(N)이 된다. 메모리 할당의 경우 선언시 컴파일 타임에 할당이 되는 정적 메모리 할당을 사용한다.

- LinkedList는 새로운 요소가 할당된 메모리 위치 주소가 linkedlist의 이전 요소의 저장되는 방식으로, Sequential Access를 지원한다. 이때의 시간복잡도는 O(N)이다. 삽입과 삭제의 경우 linkedlist의 이전요소에 주소를 저장하거나 변경하기만 하면 되므로 시간복잡도는 O(1)이다. 메모리 할당의 경우 새로운 요소가 추가될 때 런타임에 메모리를 할당하는 동적 메모리 할당을 사용한다

## 5. 이진탐색트리(Binary Search Tree)에 대해 설명해 주세요.

- 이진탐색트리는 이진 탐색과 연결리스트를 결합한 자료구조입니다. 이진 탐색의 효율적인 탐색능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능하다는 장점이 있습니다. 특징으로는 왼쪽 트리의 모든 값이 반드시 부모 노드 보다 작아야 하고, 반대로 오른쪽 트리의 모든 값이 부모 노드보다 커야합니다. 이진 탐색 트리의 연산 시간복잡도는 O(h)(h는 트리의 높이)이며 최악의 경우 O(N)입니다.

## 5-1. 이진 탐색 트리가 O(n)이라고 하셨는데, 언제 O(n)이 되고, 이걸 균형잡아주는 트리에 대해서 아는대로 말씀해보시겠어요?

- 트리가 한쪽 방향으로만 쭉 이어져 모든 데이터들을 탐색해야만 할 때 최악의 경우가 되고, 이걸 균형잡아주는 트리는 AVL, Red-Black, B+-Tree, B-Tree, B* Tree가 있습니다.

## 5-2. Red-Black Tree랑 AVL 트리에 어떤 차이가 있을까요? 서로의 시간복잡도가 다른건가요?

- AVL 트리는 Red-Black 트리보다 보다 엄격한 균형을 이루고 있기 때문에 더 빠른 조회를 제공합니다. 또한 Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어 지지 않기 때문에 AVL트리보다 빠르게 삽입 및 제거 작업을 수행할 수 있습니다.

## 5-3. Red Black와 AVL트리는 주로 어디서 사용하는지 대표적으로 말씀해보시겠어요?

- Red-Black 트리는 맵, C++의 멀티캐스트, Java treeMap 등 대부분의 언어 라이브러리에서 사용, AVL트리는 더 빠른 검색이 필요한 데이터베이스에서 사용합니다.

## 6. B-tree에 대해서 설명해 주세요

- 데이터베이스와 파일시스템에서 많이 사용하는 자료구조중 하나로 이진트리가 자식 노드가 최대 2개인 노드를 말하는 것이라면 B-tree는 자식노드가 2개 이상인 트리를 말합니다. 또한 이때 노드내의 데이터가 1개 이상일 수 있는데, 노드 내의 최대 데이터 수가 2개라면 2차 B-tree, 3개라면 3차 B-tree라고 합니다. 모든 leaf 노드들은 같은 level에 있어야 하며 이때 노드내의 키값들은 오름차순입니다.

## 6-1. B-tree와 B+ tree의 차이점에 대해 설명해 주세요.

- B+ 트리가 B-tree는 대표적으로 데이터 저장 방법에서 가장 큰 차이가 있다. B-tree는 리프 노드와 루트 노드를 포함한 모든 노드에 데이터가 저장이 가능 하지만, B+ 트리는 리프 노드를 제외한 노드에는 키값이 저장이 되고, 리프 노드에 key값과 데이터가 함께 저장된다. 이런 점 때문에 B+ 트리는 리프 노드들을 포인터로 연결하여 링크드 리스트의 형태를 취한다. 때문에 B-tree에 비해 훨씬 쉽게 순회가 가능하다.

## 6-2. 데이터베이스 인덱스는 왜 레드블랙트리나 해쉬테이블이 아닌 B-Tree를 사용하는지에 대한 이유를 말씀해 주세요.

- 먼저 해쉬 테이블의 경우 앞의 레드 블랙 트리나 B-tree와 비교해서 탐색 시간이 가장빠르다. 하지만 DB에서는 등호(=)뿐만 아니라 부등호(<,>)도 사용하는 반면, 모든 값이 정렬 되어있지 않으므로, 해시 테이블에서는 특정 기준보다 크거나 작은 값을 찾을 수 없습니다(물론 굳이 찾을 수 있지만 매우 비효율적). 또한 레드 블랙 트리의 경우 탐색의 시간이 B-Tree와 같이 O(logn)으로 같지만, 실제 DB에서의 탐색에 있어서 하나의 노드에 여러개의 데이터 요소를 담고있는 B-tree에 비해 같은 데이터를 담고 있을 때, 보다 많은 양의 노드들을 가지게 되고, 포인터의 개수도 많아진다. 따라서 비록 같은 시간복잡도를 갖고 있지만, 포인터 접근 수의 차이로 인해 실제 탐색 시간은 B-tree가 레드 블랙 트리보다 더 빠를 수 밖에 없다. 따라서 데이터베이스에서는 B-tree를 주로 사용한다.

- **참고 :　https://helloinyong.tistory.com/296**

## 7. LRU 캐시 알고리즘에 대해서 알고 계신가요? LRU 캐시 알고리즘이 무엇이고, 어떤 자료구조로 구성되어있는지 간단히 말씀해보시겠어요?

- LRU 캐시 알고리즘이란, Least Recently Used Algorithm 의 약자로, 캐시에 공간이 부족할 때 가장 오랫동안 사용하지 않은 항목을 제거하고 새로운 녀석을 배치하는 형식으로 동작 합니다. // 구성은 Double Linked List과 HashMap으로 구성

## 7-1. Double Linked List라고 대답하셨는데, Single LinkedList로 해도 되지 않나요? 왜 Double Linked List로 해야 하는지 시간복잡도랑 연관지어서 설명해보시겠어요?

- 일반적으로 LRU는 넣을 때는 Head 바로 다음, 그리고 값을 읽었을 때는 Tail에서 바로 앞에서 진행되기 때문에, Double Linked List로 구현해야합니다. 그렇게 해야지만 put과 get 둘 다 O(1)의 시간복잡도를 가지고 있기 때문입니다.

## 7-2. LRU 캐시에 대해 동작방식에 대해서 설명해보시겠어요?

- **참고: https://jjongdev.notion.site/LRU-Cache-89464f87e2284eb7afd39d45b647a7d5**

## 8. 해시, 해시 함수, 해싱에 대해서 설명해보세요.

- 해시(Hash) 란 데이터를 다루는 기법 중 하나이며,해시 함수(Hash Function) 는 데이터를 효율적으로 관리하기 위해서 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 매핑 전 원래 데이터의 값을 키(Key), 매핑 후 데이터의 값을 해시값(Hash Value) 또는해시코드라고 하며, 키(Key)와 값(Value)으로 매핑되는 과정 자체를 해싱(Hashing)이라고 한다.

## 8-1. 해시를 왜 쓴다고 생각하시나요?

- 검색과 저장이 아주 빠르기 때문에 사용합니다. 데이터를 검색할 때 사용할 key와 실제 데이터의 값이 (value가)  한 쌍으로 존재하고, key값이 배열의 인덱스로 변환되기 때문에 1:1 매칭이 되면서 검색과 저장의 평균적인 시간 복잡도가 O(1)에 수렴하게 됩니다.

## 8-2. 해시테이블이 충돌을 완화하기 위해서 몇가지 방법을 쓰는데, 어떤 방법들이 있는지 아시나요? 각각에 대해서 간략하게 설명해보시곘어요?

- 크게는 (Separating) Chaining 와 Open addressing이 있습니다. Chaining은 충돌이 발생했을 때 이를 동일한 버킷(Bucket)에 저장하는데 이를 연결리스트 형태로 저장하는 방법을 말하고, Open addressing은 인덱스에 대한 충돌 처리에 대해서 Linked List와 같은 추가적인 메모리 공간을 사용하지 않고, hash table array의 빈공간을 사용하는 방법을 말합니다.

## 8-3. Open Addressing에서 probing 즉, 빈 공간을 찾기 위해 탐색을 진행하는데, Open Addressing에서 탐색은 어떤 것이 있는지 여쭤보고 싶습니다.

- 선형탐사, 제곱탐사, 이중해시

## 8-4. 선형탐사와 제곱탐사에 단점은 무엇이라고 생각하시나요?

- 선형탐사는 가장 기본적인 충돌해결기법으로 위에서 설명한 기본적인 동작방식으로, 바로 인접한 인덱스에 데이터를 삽입해가기 때문에 데이터가 밀집되는 프라이머리 클러스터링(Primary Clustering) 문제가 발생한다. 제곱탐사는 Secondary Clustering 문제가 발생합니다.

## 8-5. 그렇다면, Java는 어떤 방식으로 진행을 하며, 일반적인 Chaining과 다른 것은 무엇이라고 생각하나요?

- Java는 기본적으로 Chaining 기법을 사용하고, Java8 이전에는 Linked List 그리고 Java8 이후에는 data가 6개 이하면 Linked List, 8개 이상은 Red-Black Tree 자료구조를 사용합니다.

## 8-6. data가 6개 이하에는 Linked List이고 8개 이상일 때 Red-Black 트리라고 하셨는데, 왜 기준을 이렇게 잡은지에 대해서 알고 계신가요?

- 만약 기준점을 7로 하게 되면 Linked List와 Red-Black Tree로 바꿀 때 오버헤드가 발생하기 때문에 기준점을 6과 8로 하였다.

## 9. 그래프를 탐색하는 알고리즘이 어떤 것이 있는지 아는대로 말씀해보시겠어요?

- 깊이우선탐색(DFS), 너비우선탐색(BFS), Minimum Spanning Tree, 크루스칼 알고리즘이 있습니다.

## 9-1. DFS와 BFS를 말씀하셨는데, 일반적으로 DFS와 BFS가 어떤 것이고, 어떤 자료구조를 사용 하는지 말씀해보시겠어요?

- DFS : 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아간 다라는 방법을 우선으로 탐색한다. Stack으로 구현
- BFS : 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다. Queue로 저장하는 방식을 사용한다.
