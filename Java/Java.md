# 면접 질문------### 1. JVM이란 무엇이며 그 구조는 어떻게 되어있나요?- **JVM은 자바 가상머신으로 자바의 철학인 플랫폼 독립성을 실현하기 위한 목적으로 만들어졌으며 자바 바이트코드의 실행 환경**이다. JVM은 **Java Virtual Machine Specification**에 맞추어 개발된 여러가지 버전이 있다.- JVM은 크게 **Class loader, Runtime data 영역, 실행 엔진**으로 구성되어 있으며 각 파트의 주요 기능은 다음과 같다.    - **Class Loader :**     class가 처음으로 참조될 때 해당 class 파일이 실행 가능한 상태인지 검증하고 Runtime data 영역에 해당 부분을 동적으로 로드하는 역할을 한다.    - **Runtime Data 영역 :**     JVM Memory에 해당하는 부분으로 PC 레지스터, JVM 스택 영역, Native method 스택, Heap, Method 영역이 있다. PC 레지스터는 현재 실행 중인 instruction의 주소를 저장하고 스택 영역은 메소드의 parameter, 지역 변수 등이 저장되는 영역이다. 스택 영역은 스레드 하나당 한 개씩 할당된다. Native method 스택은 바이트코드 이외의 기계어로 작성된 것들을 실행시키는 영역이다. JVM 스택에서 JNI 등의 Native Method를 호출하게 되면 해당 JVM 스택에서 Native method 스택으로 동적 링킹을 통해 확장되어 실행된다. Heap은 동적으로 만들어진 모든 클래스의 인스턴스를 저장하는 영역이다. Method 영역은 클래스 이름, 부모 클래스 이름, 메소드 정보, 정적 변수 등 클래스에 대한 정보가 저장되는 영역이다.    - **실행 엔진 영역 :**     바이트코드의 실행을 담당하는 영역으로 Runtime Data 영역과 상호작용하며 해당 바이트코드를 실행한다. 바이트코드 인터프리터, JIT 컴파일러, GC의 세 영역으로 이루어져 있다. 바이트코드 인터프리터는 바이트코드를 명령어 단위로 읽어서 실행하며 이 때문에 느리다. 이를 보완하기 위해 JIT 컴파일러가 도입되었으며, JIT 컴파일러는 자주 실행되거나 많이 실행되는 등 어느 시점이 되면 해당 바이트코드 전체를 컴파일하여 Native 코드로 변환하여 캐시에 저장한 뒤 다음 실행 시점부터는 Native 코드로 실행하여 빠른 실행을 보장한다. GC는 Heap에서 사용되지 않는 클래스의 인스턴스를 제거하는 Garbage Collection을 수행한다.### 2.  java 파일을 실행하기까지의 과정을 추가적으로 설명해 보세요- 자바로 프로그래밍 된 파일을 javac(자바 컴파일러)가 class 파일로 만들고 이 파일이 클래스 라이브러리와 함께 **클래스 로더를 통해 실행**되게 된다.### 3. JVM Heap 영역의 구조를 설명하고 GC의 동작 방식을 설명하시오.- JVM Heap과 GC는 다음 두 가지 전제조건이 맞다는 가정 하에 설계되었다.- 대부분의 객체는 금방 접근 불가능한 상태가 되며 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.- 이 전제 조건을 토대로 JVM Heap 영역은 Young Generation 영역, Old Generation 영역의 두 가지로 나누어지게 되었고 각 영역은 다음과 같은 역할을 담당한다.- Young Generation 영역에는 새롭게 생성된 객체의 대부분이 저장된다. 대부분의 객체는 금방 접근 불가능한 상태가 되기 때문에 수많은 객체가 Young Generation 영역에 머물다가 사라지게 되고 이 경우를 Minor GC가 발생했다고 한다.- Old Generation 영역에서는 Young Generation에서 접근 불가능한 상태가 되지 않아 살아남은 객체가 복사되게 된다. 이를 Promotion이라고 하고 Young Generation 영역에 비해 GC의 빈도는 적다. 이 영역에서 객체가 사라지면 Major GC(Full GC)가 발생했다고 한다.- GC는 Stop the world, Mark and Sweep이라는 두 가지 과정을 통해 발생하고 각각은 다음과 같다.    - Stop the world는 GC를 하기 위해 JVM이 애플리케이션의 실행을 멈추는 작업이다. 해당 과정에서 GC가 실행되는 쓰레드를 제외한 모든 쓰레드의 작업이 중단되고 GC의 완료 이후에 나머지 쓰레드들의 작업이 재개된다. Stop the world는 각 작업 쓰레드들의 입장에서 순수한 오버헤드기 때문에 GC의 성능 튜닝은 보통 Stop the world의 시간을 줄이는 방향으로 많이 이루어진다.    - Mark and Sweep 과정은 이름 그대로 Mark와 Sweep 과정으로 이루어져 있다. Mark는 사용되고 있는 메모리와 그렇지 않은 메모리를 식별하는 작업이고 Sweep 과정은 Mark에서 식별된 사용되지 않는 메모리를 해제하는 작업이다.### 4. Java에서 GC를 직접 실행시키려면 어떻게 해야 하는가? GC를 실행하면 바로 실행되는가? (GC를 사용자가 원하는 시점에 실행시킬 수 있는가?)- System.gc() 혹은 Runtime.getRuntime().gc()를 실행한다. **GC의 실행 시점은 전적으로JVM이 결정하기 때문에 사용자가 수동으로 GC 요청을 한다고 해서 바로 실행되지 않는다**.### 5. Minor GC의 수행 방법을 말해주세요.- 먼저 New/Young영역의 GC방법을 살펴보자 New/Young 영역의 GC를 Minor GC라고 부르는데, New/Young영역은 Eden과 Survivor라는 두가지 영역으로 또 나뉘어 진다. Eden영역은 Java 객체가 생성되자 마자 저장이 되는곳이다. 이렇게 생성된 객체는 Minor GC가 발생할때 Survivor 영역으로 이동된다.- Survivor 영역은 Survivor 1과 Suvivor2 영역 두 영역으로 나뉘어 지는데, Minor GC가 발생하면 Eden과 Survivor1에 Alive되어 있는 객체를 Suvivor2로 복사한다. 그리고 Alive되어 있지 않는 객체는 자연히 Suvivor1에 남아있게 되고, Survivor1과 Eden영역을 Clear한다. (결과적으로 Alive된 객체만 Survivor2로 이동한것이다.)- 다음번 Minor GC가 발생하면 같은 원리로 Eden과 Survivor2영역에서 Alive되어 있는 객체를 Survivor1에 복사한다. 계속 이런 방법을 반복적으로 수행하면서 Minor GC를 수행한다.- 이렇게 Minor GC를 수행하다가, Survivor영역에서 오래된 객체는 Old영역으로 옮기게 된다.- 이런 방식의 GC 알고리즘을 **Copy & Scavenge**라고 한다. 이 방법은 매우 속도가 빠르며 **작은 크기의 메모리를 Collecting하는데 매우 효과적**이다. Minor GC의 경우에는 자주 일어나기 때문에, GC에 소요되는 시간이 짧은 알고리즘이 적합하다.### 5. Major GC의 수행 방법을 말해주세요.- Old 영역의 Garbage Collection을 Full GC라고 부르며, Full GC에 사용되는 알고리즘은 **Mark & Compact**라는 알고리즘을 이용한다. **Mark & Compact** 알고리즘은 **전체 객체들의 reference를 쭉 따라가다면서 reference가 연결되지 않는 객체를 Mark**한다. 이 작업이 끝나면 사용되지 않는 객체를 모두 Mark가 되고, 이 mark된 객체를 삭제한다. (**실제로는 compact라고 해서, mark된 객체로 생기는 부분을 unmark된 즉 사용하는 객체로 메꾸어 버리는 방법이다.**)- Full GC는 매우 속도가 느리며, Full GC가 일어나는 도중에는 순간적으로 Java Application이 멈춰 버리기 때문에, Full GC가 일어나는 정도와 Full GC에 소요되는 시간은 Application의 성능과 안정성에 아주 큰 영향을 준다.### 6. **패키지와 모듈의 차이점을 설명하고 모듈의 도입 이유를 설명하시오.**- 패키지의 경우 **동일한 이름의 클래스 파일을 경로를 통해 구분하여 사용하기 위한 목적**으로 사용된다. 서로 관련된 클래스, 인터페이스 등을 하나의 패키지 내에 둘 수 있다.- 모듈의 경우 **여러 패키지와 이미지 등의 자원을 의존관계와 공개범위를 정의하여 모아 둔 컨테이너로서 응용프로그램의 실행에 적합한 모듈들의 집합으로만 실행 환경을 구성**할 수 있도록 하였다.- Java로 개발되는 어플리케이션이 다양해지고 점점 규모가 커지면서, 의존관계를 정의할 수 없어 생긴 유지보수성 및 구현의 어려움 / 리플렉션을 통한 접근 제어자의 우회를 통해 생긴 보안상의 이슈를 해결하기 위해 **Java 버전 9부터 모듈이라는 것이 도입**되게 되었다.### 7. 객체지향 4가지 특징과 자바 혹은 C++에서 이를 구현하기 위한 문법- **추상화 :**    - 여러 객체에서 공통된 속성과 행위를 추출하는 것 Java    - ex) 추상클래스, 인터페이스- **캡슐화 :**    - 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 클래스 내부로 감추는 것 Java ex) 접근제어자- **상속 :**    - 상위 클래스의 기능을 하위 클래스가 사용할 수 있도록 하는 것. 중복되는 코드를 줄여 코드를 재사용하기 위함.    - **Java ex) extends**- **다형성 :**    - 프로그램 언어의 각 요소들이 여러 타입에 속할 수 있는 것    - **ex) 오버로딩, 오버라이딩**### 객체지향 프로그래밍 및 설계의 다섯가지 기본 원칙에 대해 설명하시오.- **SRP(단일 책임 원칙) :** 한 클래스는 하나의 책임만 가져야 한다.- **OCP(개방-폐쇄 원칙) :** 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.- **LSP(리스코프 치환 원칙) :** 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.- **ISP(인터페이스 분리 원칙) :** 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.- **DIP(의존관계 역전 원칙) :** 프로그래머는 구체화보다 추상화에 의존해야 한다. (ex) DI### static 변수를 왜 사용하나요?- 메모리에 한번 할당되어 프로그램이 종료될 때 해제하기 때문에 객체를 생성하지 않고도 static 자원에 접근이 가능하다.- 모든 객체가 공유하는 메모리라는 장점을 지니지만, 남용할 경우 시스템 성능에 악영향을 미친다.### final이란 무엇인가요?- **상속 불가 및 불변의 상수 선언 를** 목적으로 하고 있다.- final은 상수, 메소드, 클래스에 붙일 수 있다.    - **상수**같은 경우에는 선언과 동시에 값을 입력해야만 하며, 값 변경은 허용하지 않는다    - **메소드** 같은 경우에는 오버라이딩을 하지 못하게 만든다. 즉 상속을 한 후, 오버라이딩을 사용하지 못하도록 할 때 final을 사용한다    - **클래스** 같은 경우엔 상속을 막기 위해서 보통 final을 사용합니다.> 스터디 중 나왔던 이야기 :> > > ```java> import java.util.ArrayList;> import java.util.List;> > class Main {> >     public static void main(String[] args) {>         final List<Integer> list = new ArrayList<>();>         list.add(1);>         list.add(2);>         list.add(3);>         list.add(4);>         list.add(5);>         System.out.println(list); // [1, 2, 3, 4, 5]>     }> }> ```> > - 해당 예제는 list 내부의 값이 0에서 5개로 증가했다.> - 이처럼 **final에서의 불변은 대상이 불변하는 것이 아니라 새롭게 할당하는 것을 막는다는 것을 의미한다.**> - C에서 포인터 생각하면 좋을 것이다.### 추상 클래스와 인터페이스의 차이는 무엇인가요?- . 추상 클래스의 주요한 목적은 동일한 부모를 가지는 클래스에서 상속을 받아서 자식 클래스에서 구현을 통해서 기능을 확장 시키는 것이 목표입니다. new를 사용해서 새로운 객체를 생성할 수 없고 클래스 단위의 상속이기 때문에 단일 상속만 가능합니다. 그리고 추상 메서드 뿐만아니라 일반 메서드도 작성이 가능하다. 인터페이스에 있는 모든 메서드는 static final 키워드가 붙기 때문에 모든 메서드를 구현해야 하기 때문에 구현 객체의 같은 동작을 보장한다. 인터페이스 상속을 받기 때문에 다중 상속이 가능하다.### 인터프리터 언어와 컴파일 언어의 대표적인 언어와 특징을 설명하시오.- `인터프리터 언어`는 실행과 컴파일을 동시에 수행한다. 필요한 부분만 컴파일하여 그 때 그 때 실행하기 때문에, 속도가 빠르다. 하지만, 프로그램 실행과 컴파일을 동시에 수행하기 때문에 프로그램 구동에 걸리는 시간이 느리다.- `컴파일 언어`는 한 번에 모든 코드를 기계어로 번역한다. 따라서 큰 프로젝트에서 컴파일 속도가 느리지만, 이미 컴파일을 수행했기 때문에 프로그램 구동이 매우 빠른 장점이있다.### 그러면 파이썬의 동작 과정을 아시나요?- 소스 코드 -> 바이트 코드로 컴파일 -> 기계어로 변경 컴파일 언어 아닌가?- 파이썬을 실행하면 문법적인 오류를 잡아주는데 그러면 컴파일 언어 아닌지?    - .CPython, pypy(JIT)- 인터프리터가 있다고 반드시 인터프리터 언어라고 볼 수 있는지?- 그럼 JAVA에서도 (JIT 컴파일러를 포함하여 )일부 구간에서는 기계어 코드를 바로 생성하는데 이러면 인터프리터 방식 아닌지?- 결론적으로 인터프리터와 컴파일 방식의 궁극적인 차이는 무엇인지?### 객체 지향과 절차 지향의 차이- 절차 지향 언어는 코드를 순차적으로 처리하여 프로그램 전체가 유기적으로 연결되어야 합니다. 코드를 순차적으로 처리하기 때문에 컴퓨터의 처리 구조와 유사해 실행속도가 빠르다는 것이 장점입니다.- 하지만 유기적으로 연결되어 있는 구조는 유지보수의 어려움과 엄격하게 순서가 정해져 있어서 비효율적입니다. 예를 들어, 하나의 기능에서 오류가 발생했을 경우 시스템 전체에 문제가 생기기 때문에 유지 보수의 어려움이 있습니다. 뿐만 아니라 엄격한 순서는 처리 순서를 변경하는데 많은 복잡함이 요구되어 수정에 있어 효율성이 떨어지는 단점이 있습니다. → 과도한 전역변수 사용과 스파게티 소스가 될 확률이 높고 변경과 확장이 어렵다.- 객체 지향 언어는 절차 지향의 언어의 단점을 보완하는 목적으로 탄생했습니다. 프로그램을 다수의 객체로 만들고 서로 상호 작용하도록 만든 프로그래밍 언어입니다. 상속을 통한 재사용성, 객체단위의 작업을 통한 생산성 증가, 객체 단위의 모델링이 가능한 점이 장점입니다.- 하지만 모든 객체의 역할과 기능을 이해해야 하기 때문에 느린 개발 속도, 절차 지향 언어보다 실행 속도가 느리고, 절차 지향 언어에 비해서 진입 장벽이 높아 언어 학습이 더 어렵습니다.- 절차지향 프로그래밍은 프로그램 순서와 흐름을 먼저 세우고 자료구조와 함수들을 설계하는 방식이고, 객체지향 프로그래밍은 반대로 자료구조와 이를 중심으로 모듈들을 먼저 설계한 다음에 실행순서와 흐름을 짜는 방식으로 프로그래밍을 설계합니다.### JAVA에서 사용하는 싱글톤 방식은 무엇인가요?- static으로 설정해서 자바 소스코드를 컴파일 할 때 runtime data area에 한번만 등록해서 인스턴스를 사용하는 패턴입니다.- 장단점이 무엇인가요?    - 고정된 메모리 영역을 사용해서 한번의 인스턴스 생성으로 메모리 낭비를 방지 할 수 있고 데이터를 공유가 쉽습니다.    - 동시성 문제가 발생하며 많은 데이터가 공유되면 인스턴스 간의 결합도가 높아져 OCP를 위반하게 됩니다. 또한 상태를 가지면 안됩니다.### 어댑터 패턴과 템플릿 패턴, 팩토리- 어댑터 패턴이란 무엇이고 언제 사용하나요?    - OCP를 활용한 설계 패턴이며 서로 다른 객체들이 통신 할 수 있게 중간에서 변환하는 역할을 하는 패턴입니다.    - 같이 사용할 수 없는 클래스를 연결할 때 주로 사용합니다.- 템플릿 메서드 패턴은 무엇이고 언제 사용하나요?    - DIP를 활용한 패턴이며 상위 클래스의 템플릿 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출 하는 패턴입니다. 전체적인 기능의 흐름은 동일하나 하위 클래스에서 특정 구간의 기능을 구현해서 사용할 수 있게하는 패턴입니다. -> 모든 하위 클래스에서 구현을 해야하기 때문에 코드의 양이 많아지고 유지 보수가 많아진다.- 팩토리 메서드 패턴은 무엇이고 언제 사용하나요?    - DIP를 활용한 설계 패턴이며 객체의 생성을 하위 클래스에서 하는 패턴을 말합니다. 즉, 상위 클래스는 공장으로 하위 클래스는 직접 생산을 하는 패턴으로 볼수 있습니다. 팩토리 메소드 패턴을 사용하는 이유는 클래스간의 결합도를 낮추기 위한것입니다. 결합도라는 것은 간단히 말해 클래스의 변경점이 생겼을 때 얼마나 다른 클래스에도 영향을 주는가입니다. 팩토리 메소드 패턴을 사용하는 경우 직접 객체를 생성해 사용하는 것을 방지하고 서브 클래스에 위임함으로써 보다 효율적인 코드 제어를 할 수 있고 의존성을 제거합니다. 결과적으로 결합도 또한 낮출 수 있습니다.> 참고 문헌:> - **GC 참고 문헌**- **https://bcho.tistory.com/157**# 면접 질문------### 1. JVM이란 무엇이며 그 구조는 어떻게 되어있나요?- **JVM은 자바 가상머신으로 자바의 철학인 플랫폼 독립성을 실현하기 위한 목적으로 만들어졌으며 자바 바이트코드의 실행 환경**이다. JVM은 **Java Virtual Machine Specification**에 맞추어 개발된 여러가지 버전이 있다.- JVM은 크게 **Class loader, Runtime data 영역, 실행 엔진**으로 구성되어 있으며 각 파트의 주요 기능은 다음과 같다.    - **Class Loader :**     class가 처음으로 참조될 때 해당 class 파일이 실행 가능한 상태인지 검증하고 Runtime data 영역에 해당 부분을 동적으로 로드하는 역할을 한다.    - **Runtime Data 영역 :**     JVM Memory에 해당하는 부분으로 PC 레지스터, JVM 스택 영역, Native method 스택, Heap, Method 영역이 있다. PC 레지스터는 현재 실행 중인 instruction의 주소를 저장하고 스택 영역은 메소드의 parameter, 지역 변수 등이 저장되는 영역이다. 스택 영역은 스레드 하나당 한 개씩 할당된다. Native method 스택은 바이트코드 이외의 기계어로 작성된 것들을 실행시키는 영역이다. JVM 스택에서 JNI 등의 Native Method를 호출하게 되면 해당 JVM 스택에서 Native method 스택으로 동적 링킹을 통해 확장되어 실행된다. Heap은 동적으로 만들어진 모든 클래스의 인스턴스를 저장하는 영역이다. Method 영역은 클래스 이름, 부모 클래스 이름, 메소드 정보, 정적 변수 등 클래스에 대한 정보가 저장되는 영역이다.    - **실행 엔진 영역 :**     바이트코드의 실행을 담당하는 영역으로 Runtime Data 영역과 상호작용하며 해당 바이트코드를 실행한다. 바이트코드 인터프리터, JIT 컴파일러, GC의 세 영역으로 이루어져 있다. 바이트코드 인터프리터는 바이트코드를 명령어 단위로 읽어서 실행하며 이 때문에 느리다. 이를 보완하기 위해 JIT 컴파일러가 도입되었으며, JIT 컴파일러는 자주 실행되거나 많이 실행되는 등 어느 시점이 되면 해당 바이트코드 전체를 컴파일하여 Native 코드로 변환하여 캐시에 저장한 뒤 다음 실행 시점부터는 Native 코드로 실행하여 빠른 실행을 보장한다. GC는 Heap에서 사용되지 않는 클래스의 인스턴스를 제거하는 Garbage Collection을 수행한다.### 2.  java 파일을 실행하기까지의 과정을 추가적으로 설명해 보세요- 자바로 프로그래밍 된 파일을 javac(자바 컴파일러)가 class 파일로 만들고 이 파일이 클래스 라이브러리와 함께 **클래스 로더를 통해 실행**되게 된다.### 3. JVM Heap 영역의 구조를 설명하고 GC의 동작 방식을 설명하시오.- JVM Heap과 GC는 다음 두 가지 전제조건이 맞다는 가정 하에 설계되었다.- 대부분의 객체는 금방 접근 불가능한 상태가 되며 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.- 이 전제 조건을 토대로 JVM Heap 영역은 Young Generation 영역, Old Generation 영역의 두 가지로 나누어지게 되었고 각 영역은 다음과 같은 역할을 담당한다.- Young Generation 영역에는 새롭게 생성된 객체의 대부분이 저장된다. 대부분의 객체는 금방 접근 불가능한 상태가 되기 때문에 수많은 객체가 Young Generation 영역에 머물다가 사라지게 되고 이 경우를 Minor GC가 발생했다고 한다.- Old Generation 영역에서는 Young Generation에서 접근 불가능한 상태가 되지 않아 살아남은 객체가 복사되게 된다. 이를 Promotion이라고 하고 Young Generation 영역에 비해 GC의 빈도는 적다. 이 영역에서 객체가 사라지면 Major GC(Full GC)가 발생했다고 한다.- GC는 Stop the world, Mark and Sweep이라는 두 가지 과정을 통해 발생하고 각각은 다음과 같다.    - Stop the world는 GC를 하기 위해 JVM이 애플리케이션의 실행을 멈추는 작업이다. 해당 과정에서 GC가 실행되는 쓰레드를 제외한 모든 쓰레드의 작업이 중단되고 GC의 완료 이후에 나머지 쓰레드들의 작업이 재개된다. Stop the world는 각 작업 쓰레드들의 입장에서 순수한 오버헤드기 때문에 GC의 성능 튜닝은 보통 Stop the world의 시간을 줄이는 방향으로 많이 이루어진다.    - Mark and Sweep 과정은 이름 그대로 Mark와 Sweep 과정으로 이루어져 있다. Mark는 사용되고 있는 메모리와 그렇지 않은 메모리를 식별하는 작업이고 Sweep 과정은 Mark에서 식별된 사용되지 않는 메모리를 해제하는 작업이다.### 4. Java에서 GC를 직접 실행시키려면 어떻게 해야 하는가? GC를 실행하면 바로 실행되는가? (GC를 사용자가 원하는 시점에 실행시킬 수 있는가?)- System.gc() 혹은 Runtime.getRuntime().gc()를 실행한다. **GC의 실행 시점은 전적으로JVM이 결정하기 때문에 사용자가 수동으로 GC 요청을 한다고 해서 바로 실행되지 않는다**.### 5. Minor GC의 수행 방법을 말해주세요.- 먼저 New/Young영역의 GC방법을 살펴보자 New/Young 영역의 GC를 Minor GC라고 부르는데, New/Young영역은 Eden과 Survivor라는 두가지 영역으로 또 나뉘어 진다. Eden영역은 Java 객체가 생성되자 마자 저장이 되는곳이다. 이렇게 생성된 객체는 Minor GC가 발생할때 Survivor 영역으로 이동된다.- Survivor 영역은 Survivor 1과 Suvivor2 영역 두 영역으로 나뉘어 지는데, Minor GC가 발생하면 Eden과 Survivor1에 Alive되어 있는 객체를 Suvivor2로 복사한다. 그리고 Alive되어 있지 않는 객체는 자연히 Suvivor1에 남아있게 되고, Survivor1과 Eden영역을 Clear한다. (결과적으로 Alive된 객체만 Survivor2로 이동한것이다.)- 다음번 Minor GC가 발생하면 같은 원리로 Eden과 Survivor2영역에서 Alive되어 있는 객체를 Survivor1에 복사한다. 계속 이런 방법을 반복적으로 수행하면서 Minor GC를 수행한다.- 이렇게 Minor GC를 수행하다가, Survivor영역에서 오래된 객체는 Old영역으로 옮기게 된다.- 이런 방식의 GC 알고리즘을 **Copy & Scavenge**라고 한다. 이 방법은 매우 속도가 빠르며 **작은 크기의 메모리를 Collecting하는데 매우 효과적**이다. Minor GC의 경우에는 자주 일어나기 때문에, GC에 소요되는 시간이 짧은 알고리즘이 적합하다.### 5. Major GC의 수행 방법을 말해주세요.- Old 영역의 Garbage Collection을 Full GC라고 부르며, Full GC에 사용되는 알고리즘은 **Mark & Compact**라는 알고리즘을 이용한다. **Mark & Compact** 알고리즘은 **전체 객체들의 reference를 쭉 따라가다면서 reference가 연결되지 않는 객체를 Mark**한다. 이 작업이 끝나면 사용되지 않는 객체를 모두 Mark가 되고, 이 mark된 객체를 삭제한다. (**실제로는 compact라고 해서, mark된 객체로 생기는 부분을 unmark된 즉 사용하는 객체로 메꾸어 버리는 방법이다.**)- Full GC는 매우 속도가 느리며, Full GC가 일어나는 도중에는 순간적으로 Java Application이 멈춰 버리기 때문에, Full GC가 일어나는 정도와 Full GC에 소요되는 시간은 Application의 성능과 안정성에 아주 큰 영향을 준다.### 6. **패키지와 모듈의 차이점을 설명하고 모듈의 도입 이유를 설명하시오.**- 패키지의 경우 **동일한 이름의 클래스 파일을 경로를 통해 구분하여 사용하기 위한 목적**으로 사용된다. 서로 관련된 클래스, 인터페이스 등을 하나의 패키지 내에 둘 수 있다.- 모듈의 경우 **여러 패키지와 이미지 등의 자원을 의존관계와 공개범위를 정의하여 모아 둔 컨테이너로서 응용프로그램의 실행에 적합한 모듈들의 집합으로만 실행 환경을 구성**할 수 있도록 하였다.- Java로 개발되는 어플리케이션이 다양해지고 점점 규모가 커지면서, 의존관계를 정의할 수 없어 생긴 유지보수성 및 구현의 어려움 / 리플렉션을 통한 접근 제어자의 우회를 통해 생긴 보안상의 이슈를 해결하기 위해 **Java 버전 9부터 모듈이라는 것이 도입**되게 되었다.### 7. 객체지향 4가지 특징과 자바 혹은 C++에서 이를 구현하기 위한 문법- **추상화 :**    - 여러 객체에서 공통된 속성과 행위를 추출하는 것 Java    - ex) 추상클래스, 인터페이스- **캡슐화 :**    - 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 클래스 내부로 감추는 것 Java ex) 접근제어자- **상속 :**    - 상위 클래스의 기능을 하위 클래스가 사용할 수 있도록 하는 것. 중복되는 코드를 줄여 코드를 재사용하기 위함.    - **Java ex) extends**- **다형성 :**    - 프로그램 언어의 각 요소들이 여러 타입에 속할 수 있는 것    - **ex) 오버로딩, 오버라이딩**### 객체지향 프로그래밍 및 설계의 다섯가지 기본 원칙에 대해 설명하시오.- **SRP(단일 책임 원칙) :** 한 클래스는 하나의 책임만 가져야 한다.- **OCP(개방-폐쇄 원칙) :** 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.- **LSP(리스코프 치환 원칙) :** 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.- **ISP(인터페이스 분리 원칙) :** 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.- **DIP(의존관계 역전 원칙) :** 프로그래머는 구체화보다 추상화에 의존해야 한다. (ex) DI### static 변수를 왜 사용하나요?- 메모리에 한번 할당되어 프로그램이 종료될 때 해제하기 때문에 객체를 생성하지 않고도 static 자원에 접근이 가능하다.- 모든 객체가 공유하는 메모리라는 장점을 지니지만, 남용할 경우 시스템 성능에 악영향을 미친다.### final이란 무엇인가요?- **상속 불가 및 불변의 상수 선언 를** 목적으로 하고 있다.- final은 상수, 메소드, 클래스에 붙일 수 있다.    - **상수**같은 경우에는 선언과 동시에 값을 입력해야만 하며, 값 변경은 허용하지 않는다    - **메소드** 같은 경우에는 오버라이딩을 하지 못하게 만든다. 즉 상속을 한 후, 오버라이딩을 사용하지 못하도록 할 때 final을 사용한다    - **클래스** 같은 경우엔 상속을 막기 위해서 보통 final을 사용합니다.> 스터디 중 나왔던 이야기 :> > > ```java> import java.util.ArrayList;> import java.util.List;> > class Main {> >     public static void main(String[] args) {>         final List<Integer> list = new ArrayList<>();>         list.add(1);>         list.add(2);>         list.add(3);>         list.add(4);>         list.add(5);>         System.out.println(list); // [1, 2, 3, 4, 5]>     }> }> ```> > - 해당 예제는 list 내부의 값이 0에서 5개로 증가했다.> - 이처럼 **final에서의 불변은 대상이 불변하는 것이 아니라 새롭게 할당하는 것을 막는다는 것을 의미한다.**> - C에서 포인터 생각하면 좋을 것이다.### 추상 클래스와 인터페이스의 차이는 무엇인가요?- . 추상 클래스의 주요한 목적은 동일한 부모를 가지는 클래스에서 상속을 받아서 자식 클래스에서 구현을 통해서 기능을 확장 시키는 것이 목표입니다. new를 사용해서 새로운 객체를 생성할 수 없고 클래스 단위의 상속이기 때문에 단일 상속만 가능합니다. 그리고 추상 메서드 뿐만아니라 일반 메서드도 작성이 가능하다. 인터페이스에 있는 모든 메서드는 static final 키워드가 붙기 때문에 모든 메서드를 구현해야 하기 때문에 구현 객체의 같은 동작을 보장한다. 인터페이스 상속을 받기 때문에 다중 상속이 가능하다.### 인터프리터 언어와 컴파일 언어의 대표적인 언어와 특징을 설명하시오.- `인터프리터 언어`는 실행과 컴파일을 동시에 수행한다. 필요한 부분만 컴파일하여 그 때 그 때 실행하기 때문에, 속도가 빠르다. 하지만, 프로그램 실행과 컴파일을 동시에 수행하기 때문에 프로그램 구동에 걸리는 시간이 느리다.- `컴파일 언어`는 한 번에 모든 코드를 기계어로 번역한다. 따라서 큰 프로젝트에서 컴파일 속도가 느리지만, 이미 컴파일을 수행했기 때문에 프로그램 구동이 매우 빠른 장점이있다.### 그러면 파이썬의 동작 과정을 아시나요?- 소스 코드 -> 바이트 코드로 컴파일 -> 기계어로 변경 컴파일 언어 아닌가?- 파이썬을 실행하면 문법적인 오류를 잡아주는데 그러면 컴파일 언어 아닌지?    - .CPython, pypy(JIT)- 인터프리터가 있다고 반드시 인터프리터 언어라고 볼 수 있는지?- 그럼 JAVA에서도 (JIT 컴파일러를 포함하여 )일부 구간에서는 기계어 코드를 바로 생성하는데 이러면 인터프리터 방식 아닌지?- 결론적으로 인터프리터와 컴파일 방식의 궁극적인 차이는 무엇인지?### 객체 지향과 절차 지향의 차이- 절차 지향 언어는 코드를 순차적으로 처리하여 프로그램 전체가 유기적으로 연결되어야 합니다. 코드를 순차적으로 처리하기 때문에 컴퓨터의 처리 구조와 유사해 실행속도가 빠르다는 것이 장점입니다.- 하지만 유기적으로 연결되어 있는 구조는 유지보수의 어려움과 엄격하게 순서가 정해져 있어서 비효율적입니다. 예를 들어, 하나의 기능에서 오류가 발생했을 경우 시스템 전체에 문제가 생기기 때문에 유지 보수의 어려움이 있습니다. 뿐만 아니라 엄격한 순서는 처리 순서를 변경하는데 많은 복잡함이 요구되어 수정에 있어 효율성이 떨어지는 단점이 있습니다. → 과도한 전역변수 사용과 스파게티 소스가 될 확률이 높고 변경과 확장이 어렵다.- 객체 지향 언어는 절차 지향의 언어의 단점을 보완하는 목적으로 탄생했습니다. 프로그램을 다수의 객체로 만들고 서로 상호 작용하도록 만든 프로그래밍 언어입니다. 상속을 통한 재사용성, 객체단위의 작업을 통한 생산성 증가, 객체 단위의 모델링이 가능한 점이 장점입니다.- 하지만 모든 객체의 역할과 기능을 이해해야 하기 때문에 느린 개발 속도, 절차 지향 언어보다 실행 속도가 느리고, 절차 지향 언어에 비해서 진입 장벽이 높아 언어 학습이 더 어렵습니다.- 절차지향 프로그래밍은 프로그램 순서와 흐름을 먼저 세우고 자료구조와 함수들을 설계하는 방식이고, 객체지향 프로그래밍은 반대로 자료구조와 이를 중심으로 모듈들을 먼저 설계한 다음에 실행순서와 흐름을 짜는 방식으로 프로그래밍을 설계합니다.### JAVA에서 사용하는 싱글톤 방식은 무엇인가요?- static으로 설정해서 자바 소스코드를 컴파일 할 때 runtime data area에 한번만 등록해서 인스턴스를 사용하는 패턴입니다.- 장단점이 무엇인가요?    - 고정된 메모리 영역을 사용해서 한번의 인스턴스 생성으로 메모리 낭비를 방지 할 수 있고 데이터를 공유가 쉽습니다.    - 동시성 문제가 발생하며 많은 데이터가 공유되면 인스턴스 간의 결합도가 높아져 OCP를 위반하게 됩니다. 또한 상태를 가지면 안됩니다.### 어댑터 패턴과 템플릿 패턴, 팩토리- 어댑터 패턴이란 무엇이고 언제 사용하나요?    - OCP를 활용한 설계 패턴이며 서로 다른 객체들이 통신 할 수 있게 중간에서 변환하는 역할을 하는 패턴입니다.    - 같이 사용할 수 없는 클래스를 연결할 때 주로 사용합니다.- 템플릿 메서드 패턴은 무엇이고 언제 사용하나요?    - DIP를 활용한 패턴이며 상위 클래스의 템플릿 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출 하는 패턴입니다. 전체적인 기능의 흐름은 동일하나 하위 클래스에서 특정 구간의 기능을 구현해서 사용할 수 있게하는 패턴입니다. -> 모든 하위 클래스에서 구현을 해야하기 때문에 코드의 양이 많아지고 유지 보수가 많아진다.- 팩토리 메서드 패턴은 무엇이고 언제 사용하나요?    - DIP를 활용한 설계 패턴이며 객체의 생성을 하위 클래스에서 하는 패턴을 말합니다. 즉, 상위 클래스는 공장으로 하위 클래스는 직접 생산을 하는 패턴으로 볼수 있습니다. 팩토리 메소드 패턴을 사용하는 이유는 클래스간의 결합도를 낮추기 위한것입니다. 결합도라는 것은 간단히 말해 클래스의 변경점이 생겼을 때 얼마나 다른 클래스에도 영향을 주는가입니다. 팩토리 메소드 패턴을 사용하는 경우 직접 객체를 생성해 사용하는 것을 방지하고 서브 클래스에 위임함으로써 보다 효율적인 코드 제어를 할 수 있고 의존성을 제거합니다. 결과적으로 결합도 또한 낮출 수 있습니다.> 참고 문헌:> - **GC 참고 문헌**- **https://bcho.tistory.com/157**