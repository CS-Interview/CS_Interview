# 네트워크 면접 질문

## *OSI 3 - 7 계층을 설명해보세요.

### 3계층 - 네트워크 층

데이터를 목적지까지 빠르고 안전하게 전달하는 기능을 담당합니다. 라우터를 이용해 이동할 경로를 선택하여, IP 주소를 지정하고 해당 경로로 패킷을 전달하는 역할을 담당합니다.

⇒ 라우팅, 흐름제어, 오류제어 등을 수행합니다.

### 4계층 - 전송계층

전송계층은 양 끝단(end to end)의 사용자들이 데이터를 서로 주고받을 수 있도록 하는 계층입니다. 

### 5계층 - 세션계층

데이터가 통신하기 위한 논리적 연결을 담당합니다. TCP/IP 세션을 만들고 없애는 책임을 지니고 있습니다. 

### 6계층 - 표현계층

표현계층은 코드간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용계층으로부터 줄여줍니다. MIME인코딩이나 암호화 등의 동작이 이 계층에서 이뤄지게됩니다.

### 7계층 - 응용계층

응용 계층은 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행합니다. 일반적으로 사용자가 사용하는 인터페이스를 이 계층에서 제공합니다.

## *왜 이렇게 계층을 분리할까요?

각 계층이 독립성을 갖추고 있기 때문에, 네트워크 확장성 측면에서 효율적이기 때문입니다. 

또한 통신이 일어나는 과정을 과정별로 추적할 수 있고, 특정 계층에 이상이 생겼을 경우, 해당 계층만 수정하면 되는 장점이 있습니다. 

## 통신 프로토콜의 의미가 무엇일까요?

프로토콜은 협약, 규약 약속을 의미하는 단어로, 서로 다른 운영체제 간 통신을 위해 세워놓은 규약을 의미합니다. 이 프로토콜을 정의해 놓음으로써 상호간 원할한 교류, 소통을 달성할 수 있게 됩니다.

## TCP / IP의  각 계층의 프로토콜과 전송 단위에 대해서 한번 말씀해 주세요.

1. 네트워크 계층
    1. IP, ARP, RAPR, ICMP
    2. 전송 단위: packet
2. 전송 계층 
    1. TCP, UDP
    2. 전송 단위: Segment or Diagram
3. 응용 계층
    1. HTTP, HTTPS, IMAP3, SMTP, POP3, DHCP, DNS
    2. 전송 단위: message

## *ARP는 어떤 프로토콜인가요?

IP 주소를 이용해 MAC 주소를 찾는 프로토콜입니다. 

## *(답을 했다면) ARP 프로토콜이 왜 필요할까요?

이더넷 헤더에 이더넷 통신을 위한 MAC 주소를 추가해야 하는데 이를 알기 위함입니다. 

같은 네트워크 상에서 목적지에 해당하는 물리주소를 찾기 위합니다. 

## ARP 주소 캐시에 목적지의 MAC주소가 없다고 가정했을 때, 동작 흐름을 설명해 주시겠어요?

1. 주소 해석한 IP 주소와 MAC주소의 대응을 ARP 캐시에 보존합니다.
2. 질의 받은 IP주소를 가진 호스트가 ARP 응답으로 MAC 주소를 알려줍니다.
3. ARP 프로토콜을 통해 네트워크 내에 있는 컴퓨터로 해당 IP 주소를 질의합니다.
    
    ## IP를 가지고 있다면, 굳이 브로드 캐스트의 통신 방법을 왜 선택할까요?
    
    서버 A에서 B로 `ping`을 보내려 할 때, 3계층 IP 주소까진 캡슐화할 수 있지만 목적지 MAC 주소를 모르기 때문에 2계층 캡슐화를 할 수 없어 패킷을 완성할 수 없기때문에 2계층 MAC 주소 도착지 브로드캐스트(FF-FF-FF-FF-FF-FF)로 브로드캐스트 해야합니다.
    

## ICMP는 어떤 프로토콜인지 아시나요?

일반적으로 IP 패킷을 이용한 통신은 최선형 통신입니다. 이는 "보내는데에는 최선을 다했지만 도달하지 않았다면 어쩔 수 없지" 란 의미로 요청을 전달하는 데에는 최선을 다하지만 요청자 입장에서는 해당 패킷이 도달했는지, 도달하지 않았다면 이유가 무엇인지에 대해 알 수가 없습니다. 이에 별도로 IP에 의한 엔드 투 엔드 통신이 정상적으로 이루어졌는지 확인하는 프로토콜이 ICMP(Internet Control Message Protocol) 입니다.

이 프로토콜을 이용해 사용자는 사전에 통신이 가능한지 확인해 볼 수 있고, 패킷이 전달도중 폐기 되었다면 그 원인 또한 전달받을 수 있게됩니다.

## *IP vs Mac 주소의 차이가 무엇인가요?

우선 가장 큰 차이는 각각의 주소를 사용하는 계층이 다르다는 것입니다.

IP 는 네트워크 계층에서 MAC 주소는 데이터 링크 계층에서 사용됩니다. 고로 IP주소는 논리주소라고 표현할 수 있고, MAC주소는 각 하드웨어의 물리 주소라고 표현할 수 있습니다.

## 왜 Mac 주소와 IP주소를 분리하는 이유에 대해 알고 계신가요?

MAC 주소는 전적으로 물리 주소에 해당합니다. 하나의 물리주소를 가진 하드웨어는 네트워크를 이곳 저곳 변경될 가능성이 있고, 이에 따라 전송 목적지가 달라지게 되는데, 송신자 입장에선 해당 MAC 주소로 전송을 하고자 할때 어떤 경로로 전송을 해야하는 지 알 수 없게 됩니다.

또한, 네트워크 안에 속하는 노드들이 같은 네트워크 prefix를 갖도록 하여 네트워크 계층화를 이루기 때문에 효율적으로 그 다음 목적지를 추적할 수 있으나, 물리주소는 같은 네트워크에 있더라도 그 주소가 천차만별이기 때문에 그 라우팅 효과를 달성하기 어렵습니다.

## *IPV4의 한계를 해결하기 위해서 그간 어떤 해결책들이 있었을까요?

- CIDR
    - Classless Inter-Domain Routing으로 클래스 없는 도메인간 라우팅 방법입니다.
    - class 구분 없이 네트워크 구분을 하기 때문에 유연하게 IP를 활용할 수 있다는 장점이 있습니다.
    - 출처
        
        [[네트워크] CIDR이란?(사이더 란?)](https://kim-dragon.tistory.com/9)
        
- 서브넷
    
    ## *서브넷은 무엇인가요?
    
    네트워크를 서브 네트워크로 나눈다는 의미로 네트워크를 세분화하는 것을 의미합니다.
    
    host 주소 중 일부분을 필요한 만큼 서브 네트워크로 분할해 사용, 기존에 네트워크 길이와 호스트길이가 고정적이라 낭비되는 IP가 많았기 때문에 이를 개선합니다.
    
    ## 서브넷팅을 하는 목적이 무엇일까요?
    
    - 효율성
        - 필요와 편의에 따라 IP를 효율적으로 나누어 IP의 낭비를 막을 수 있습니다.
    - 성능
        - 네트워크를 세분화함으로써 브로드캐스트 범위를 좁힐 수 있습니다. (불필요한 요청을 줄일 수 있음)
        - 이에 따른 순기능으로 브로드캐스트로 인한 트래픽을 줄입니다.
    - 보안
        - 네트워크를 세분화 함으로써 이슈에 따른 파급력을 확장을 예방합니다.
        - 즉, 보안성이 향상됩니다.
    
    ## 103.9.32.146/24 네트워크를 서브네팅하려고 합니다. 해당 네트워크 내에 IP가 필요한 호스트가 최대 16개일 때, 서브넷 마스크를 어떻게 설정해야 할까요?
    
    - 255.255.255.240
    - 출처
        - [https://limkydev.tistory.com/166?category=954021](https://limkydev.tistory.com/166?category=954021)
        
- IPV6
    
    ## IPV6란 무엇인가요?
    
    기존의 32비트(IPV4)로는 할당해줄 IP가 부족하기 때문에 새롭게 정의된 128 비트의 주소를 갖는 IP체계를 의미합니다.
    
- NAT
    
    ## NAT란 무엇인가요?
    
    NAT는 공인 IP는 사설 IP로 변환해주는 통신망 주소 변환기 입니다. 
    
    즉, 공인 IP 대신 사설 IP 주소를 사용할 수 있도록 하여 인터넷 공인 IP 주소를 절약하고, 사설망을 침입자들로부터 보호하기 위해 사용합니다.
    
    ## (사설 IP, 공인 IP를 언급했다면) 사설 IP, 공인 IP 는 무엇인가?
    
    공인 IP는 인터넷에서 사용하는 IP 주소로 전 세계를 통틀어 유일한 주소입니다. 인터넷에서 통신하기 위해서는 반드시 공인 IP가 필요합니다. 
    
    반면 사설 IP는 사내 네트워크 등에서 사용하는 IP로 특정 네트워크 내에서는 자유롭게 사용할 수 있으며, 다른 네트워크 내에 중복된 IP가 있더라도 해당 IP가 존재하는 네트워크 내에서의 통신에는 아무런 영향을 끼치지 않습니다.
    
    ## 목적지와 출발지를 사설 IP로 지정 했을 경우에 네트워크의 흐름을 설명해 보세요.
    
    목적지가 사설 주소인 응답은 폐기 되어, 목적지에 전송되지 않습니다. 
    
    ## 어 그렇다면 출발지는 상관없나요? 출발지는 사설 주소로 설정되어야 하는데 사설 네트워크에서 인터넷으로 통신하기 위해선 어떻게 해야 하나요?
    
    사설 IP로 설정된 출발지는 NAT를 통해 사설 IP에서 공인 IP로 주소가 변환되기 때문에 괜찮습니다.
    
- DHCP
    
    ## DHCP 프로토콜은?
    
    TCP/IP를 이용해 통신하기 위해서는 각종 네트워크 기기에 TCP/IP에 대한 설정이 바르게 되어 있어야만 합니다. 이 설정을 네트워크 접속 시, 자동화하기 위한 프로토콜입니다.
    
    즉, 사용되지 않는 IP를 재활용하고, 필요한 곳에 재할당 해줌으로써 IP 주소의 가용성을 높여줍니다. 
    
    ## 어떻게 자동으로 IP를 할당 받는지 DHCP 동작순서에 대해 한번 설명해 주시겠어요?
    
    1. DHCP DISCOVER
        
        클라이언트 브로드 캐스트 요청을 통해 주변 DHCP 서버로 사용가능한 IP를 요청함
        
    2. DHCP OFFER
        
        요청을 받은 DHCP 서버들은 해당 클라이언트에게 가용한 IP 주소에 대한 제공 의사가 있음을 밝힘
        
    3. DHCP REQUEST
        
        클라이언트는 단일 DHCP 서버에게 IP주소 사용 승인 요청
        
    4. DHCP ACK
        
        요청한 IP에 대한 사용권 승인
        
    
    ## 왜 OFFER 하고 바로 ACK를 보내지 않고, 다시 REQEUST를 보내는 이유가 무엇일까요?
    
    브로드 캐스트로 IP 요청을 보낼 때, 하나의 DHCP 서버로만 보내는 것이 아니라 여러 DHCP 서버로 보내게 되고 이에 따른 응답이 여러개 오기 때문입니다. 
    
    요청측은 이 중에서 하나의 DHCP 서버에게 IP 승인 요청을 하게 됨으로 바로 ACK를 하지 못하고 사이에 REEQUST를 한번더 보내게 됩니다.
    

## *TCP와 UDP 각각의 프로토콜은 어떤 차이가 있나요?

### TCP

대부분의 인터넷 응용 분야들은 **신뢰성** 과 **순차적인 전달** 을 필요로 합니다. UDP 로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 `TCP`입니다. `TCP(Transmission Control Protocol, 전송제어 프로토콜)`는 신뢰성 있는 애플리케이션 간 데이터 전송을 위한 프로토콜로써, TCP를 이용하면 응용 계층에서는 신뢰성을 확보하기 위한 노력을 따로 하지 않아도 됩니다.

모든 TCP 연결은 전이중(full-duplex), 점대점(point to point)방식으로 이루어집니다. 

전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며, 점대점이란 각 연결이 정확히 2 개의 종단점을 가지고 있음을 의미합니다. 

### UDP

UDP 프로토콜을 비연결성 프로토콜로서, 최소한의 오류검출만을 담당하며 흐름제어, 오류제어, 유실된 패킷의 재전송과 같은 제어기능이 없습니다. 종종 클라이언트가 서버측으로 짧은 요청을 보내고, 빠른 응답을 기대할 때 사용됩니다.

## TCP를 사용하는 응용 계층의 프로토콜은 무엇이 있을까요?

HTTP, HTTPS, SMTP, POP3, IMAP4 등

## 각각의 프로토콜이 쓰이는 상황에 대해 두 개씩만 말씀해 주세요.

TCP - 메일 전송, 웹 브라우저 접속

UDP - 영상 시청, DNS, 게임

## *DNS가 무엇인가요?

DNS는 Domain Name Service로 각 컴퓨터 별 기억하기 어려운 IP 주소를 사용자가 기억하기 쉽도록 IP를 사용자가 이용할 수 있도록 하기 위해 고안된 서비스입니다. 

## 그럼 IP 말고 도메인을 이용하지 왜 이 둘을 구분지었을까요?

## www.google.com을 쳤을 때, 가장 가까운 DNS서버에 해당 도메인 네임이 등록되어 있지 않을 경우, 어떤 경로로 찾게 되나요?

일반적으로 도메인 명이라는 계층적 구조를 이용해 최상위 도메인 에서부터 그 다음계층으로 조사해 나갑니다. 최상위 계층에서 com 도메인 서버로, [google.com](http://google.com) 도메인 서버로 [www.google.com](http://www.google.com) 도메인 서버로 계층적으로 접근해 질의한 뒤, 도메인에 대한 IP 주소를 넘겨받습니다.

## ‘리졸버’에 대해서 알고계신가요?

'리졸버'는 DNS 클라이언트로써 분석하여 답을 내거나 변형해 주는 것을 의미합니다.

OS에 포함되어있는 네트워크의 기능을 어플리케이션에서 호출하기 위한 부품들 중 하나입니다. 

## (만약 모른다면) 처음 DNS를 조사하고자 할 때, DNS 서버로 어떻게 요청을 보낸다고 생각하세요?

## DNS 서버로의 요청은 어떤 프로토콜을 이용하나요?

UDP 프로토콜을 이용합니다. 

## 왜 DNS 서버로의 요청은 UDP 프로토콜을 이용하나요?

- 연결 상태를 유지할 필요가 없기 때문입니다.
    
    TCP는 요청 기간동안 연결상태를 유지하여 클라이언트로 부터 많은 정보를 소켓에 저장해 둡니다.  
    
    반면 UDP는 어떠한 정보도 기록하지 않고, 유지할 필요가 없기 때문에 TCP보다 UDP에서 동작할 때 **더 많은 클라이언트를 수용**할 수 있습니다.
    
    도메인네임을 ip로 변경함으로 항상 많은 클라이언트를 수용하는 dns 서버에게는 연결상태를 유지 하지 않아 정보 기록을 최소화 하는 udp가 더 알맞습니다.
    
- 신뢰성보다 속도가 더 중요하기 때문입니다.
    
    TCP와 달리 UDP는 연결 설정에 드는 비용을 절약할 수 있습니다. 만약 TCP를 이용한다면 연결과정에 드는 시간이 또 발생하기 때문에 요청에 따른 응답이 UDP보다 느릴 수 밖에 없습니다. 신뢰성보다 빠른 응답을 원하는 DNS요청에는 UDP가 더 적합하다고 볼 수 있습니다.
    

## 부하분산을 위한 DNS 서버 구성 방법들에 대해 설명해주세요.

- Round Robin
    - IP를 요청하는 쿼리를 받을 때마다 해당 웹 서버들에게 순차적으로 인계합니다.
- Synchronous Time-Division Multiplexing
    - AP 서버에 VIP를 부여하여 다중화를 구상합니다. 각 AP 서버를 Health check한 후 이상이 감지되면 VIP를 정상 AP 서버로 인계합니다.
- Weighted Round Robin
    - 각 웹 서버에 가중치를 설정하여 분산 비율을 결정합니다.
- Least Connection
    - 접속 클라이언트가 가장 적은 AP 서버에 인계합니다.
1. DNS Round Robin 방식의 문제점에 대해 설명하라.
    - AP 서버의 개수만큼 공인 IP가 필요합니다.
    - 균등하게 분산 되지 않습니다.
    - 서버가 다운되어도 확인할 수 없습니다.
- 출처
    - [http://dailusia.blog.fc2.com/blog-entry-362.html](http://dailusia.blog.fc2.com/blog-entry-362.html)

## *TCP 프로토콜은 어떤 방법으로 데이터 전송의 신뢰성과 데이터의 순서를 보장할 수 있을까요? TCP 헤더의 필드를 바탕으로 설명해주세요.

TCP 헤더의 시쿼스 번호로 데이터의 순서를 나타내고, ACK필드로 패킷을 잘 했음을 알립니다.  

이러한 이유로 패킷 헤더의 시퀀스 번호로 데이터의 순서를 보장하고, 송신측에 건내는 ACK값이 담긴 패킷으로 어떤 패킷이 유실되었는지 추적할 수 있습니다. 만약 ACK 전달되지 않았다면 송신측에서는 유실되었다고 판단하여 해당 패킷을 재전송 합니다.

## TCP 프로토콜을 이용한 통신을 할 때, 유실된 패킷을 어떻게 재전송 할까요?

아래 질문에 답이 있습니다.

## (시퀀스 번호와 ACK 번호를 언급했다면) 처음 시작하는 시퀀스 번호를 어떻게 결정하는 줄 아시나요?

정석적으로 1부터 시퀀스 번호가 시작된다면, 패킷의 시퀀스 번호가 쉽게 추적이 가능해지기 때문에 보안상의 이유로 난수로 생성됩니다.

## (난수를 언급했다면) 난수로 시작을 하면, 어떤 값이 가장 맨 앞에 오는 값인지 혹은 이전에 값이 누락이 되었는지 어떻게 알 수 있을까요?

해당 부분은 소켓 컨넥션(3-way handshaking) 당시, 클라이언트와 서버간 보낼 시퀀스 번호의 초기값을 교환함으로써 난수로 생성되었지만 시작 번호를 알 수 있게됩니다. 

## **초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유는 무엇일까요?

A. Connection을 맺을 때 사용하는 포트(Port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순처적인 Number가 전송된다면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정.

- [관련 Reference](http://asfirstalways.tistory.com/356)

## TCP 혼잡 제어와 흐름 제어의 각 의미와 방식에 대해서 설명해주세요.

혼잡제어는 네트워크 상황이 혼잡할 때, 패킷 전송 시간을 좀 늦추면서 네트워크 내 혼잡함을 줄이는 것이고, 흐름제어는 수신 버퍼의 가용 상황을 바탕으로 패킷 연속 전송을 제어하는 것입니다. 

## *윈도우 제어가 무엇이고, 왜 필요할까요?

윈도우 제어는 한개의 패킷을 보낸 후, ACK 수신을 기다리지 않고 연속해서 그 다음 패킷을 계속해서 보내는 방식입니다. 

이 방식은 ACK 번호가 돌아올 떄까지 기다리지 않고, 송신하기 때문에 대기 시간에 따른 비용을 감소시킵니다.

## 그렇다면, 모든 데이터를 계속해서 전부 보내나요?

아닙니다. 수신측에는 수신버퍼를 두고, 해당 버퍼의 크기를 주기적으로 송신측에 알려줌으로써 송신측은  어느정도의 데이터를 연속적으로 보낼 수 있는지 판단합니다.

## *슬라이딩 윈도우를 이용하여 여러 패킷을 보낼 때, 만약 이 상황에서 패킷이 유실되면 어떻게 유실된 패킷을 복구하나요?

**Go Back N ARQ**

**패킷 유실 시 유실된 시점부터 재전송하는 방식입니다.**

수신측은 순서대로 패킷이 도착하지 않았을 경우 패킷을 폐기하며 NACK 패킷으로 유실된 패킷을 재전송 요청합니다. 만약 송신측은 재전송 타이머가 완료되기 전까지 응답 패킷을 받지 못할 경우 응답을 받지 못한 패킷부터 재전송합니다.

**elective Repeat ARQ**

**패킷 유실 시 유실된 패킷만 재전송하는 방식**입니다. 

수신측은 순서대로 패킷이 도착하지 않았을 경우 패킷을 버퍼에 보관하며 NACK 패킷으로 유실된 패킷을 재전송 요청합니다.

**재전송 받은 후 버퍼에 보관된 패킷과 재정렬**합니다. 만약 송신측은 재전송 타이머가 완료되기 전까지 응답 패킷을 받지 못할 경우 응답을 받지 못한 패킷부터 재전송합니다. 가장 효율적이지만 비교적 복잡하고 별도 버퍼와 재정렬이 필요합니다.

## *클라이언트와 서버간 연결이 끊겼을 때, 4-way handshake가 발생합니다. 이 handshake 순서에 대해 설명해 주세요.

## *마지막에 클라이언트가 종료 승인을하고, 바로 소켓을 소멸시키지 않고 일정시간 기다리는데 이 이유가 무엇일까요?

소멸시키지 않고. 기다리는 이유 중 하나는 클라이언트 측이 보낸 ACK 사인이 중간에서 유실될 가능성이 있기 때문입니다. 그렇다면 서버측에서 아직 ACK 를 받지 못했으니 서버측이 이전에 요청한 FIN 비트를 포함한 패킷을 다시 재전송하게 되는데 만약 클라이언트가 ACK를 보낸 후 바로 종료를 했다면, 서버 측이 재전송한 패킷을 받지 못하게 됩니다. 이런 상황을 방지하고자 일정시간 동안은 열어둔 소켓을 바로 닫지 않고, 대기합니다.

## *HTTP 프로토콜이란 무엇이며, 해당 프로토콜의 특징은 무엇인가요?

- 웹에서 자원을 주고받을 때 사용하는 어플리케이션 계층의 프로토콜입니다.
- HTTP의 특징으로는 무상태성과 비연결성이 있습니다. 클라이언트와 서버의 통신이 끝난 후, 연결이 끊기고 데이터 상태 정보를 유지하지 않습니다.

## HTTP의 무상태성, 비연결성 특성 때문에 발생하는 문제점과 문제점을 해결하기 위한 방법에는 무엇이 있을까요?

- 상태 정보를 Request Header에 넣어 통신합니다.
- 쿠키와 세션 방식, 토큰 방식이 있습니다.

## *Session 인증 방식과 Token 인증 방식의 차이점을 설명해주세요.

- 세션 기반 인증
    - 서버의 메모리나 DB에 세션을 저장하고, 클라이언트에게 세션 ID를 전송하여 쿠키에 저장합니다.
    - 이후 매 요청 시 Header에 세션 ID를 쿠키에 담아 전송하여 인증합니다.
    
    ## 로드밸런서를 사용하는 웹 서버를 구현할 경우에는 세션을 어떻게 관리할까요?
    
    - 스티키 세션
        - 로드 밸런서가 쿠키가 없는 요청이라면 쿠키 값을 등록하고 웹서버를 지정한다.
        - 쿠키가 있다면 해당 요청이 쿠키에 지정된 서버로 보낸다.
    - 세션 클러스터링
        - 클러스터링은 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하도록 만드는 것이다.
        - 즉, 각 서버의 세션에 모든 세션 저장소의 세션 객체를 복제한다.
        - 단점
            - 매번 세션 객체를 복제하는데 오버헤드가 발생한다.
    - 세션 스토리지 분리
        - 별도의 세션 저장소를 사용한다. 세션 저장소가 하나이기에 세션을 서버간 복제를 할 필요가 없다.
        - 서버가 아무리 늘어난다 해도 세션 스토리지에 대한 정보만 각각의 서버에 입력해주면 세션을 공유할 수 있다. 또한, 트래픽이 몰리는 현상을 고려하지 않아도 된다.
        - 하나의 서버가 장애가 발생해도 별도의 세션 저장소가 존재하기 때문에 서비스를 계속 제공할 수 있다. (가용성 확보)
    - 출처
        - [https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html)
        - [https://hyuntaeknote.tistory.com/6](https://hyuntaeknote.tistory.com/6)

- 토큰 기반 인증
    - 인증 받은 사용자들에게 토큰을 발급하고, 서버에 요청을 할 때 헤더에 토큰을 함께 보내 유효성을 검사합니다.
    
    ## 토큰 기반 인증의 단점은 세션 기반 인증에 비해 보안이 취약하다는 점입니다. 이 문제를 보완하기 위한 방법들을 알고 있나요?
    
    - 많이 사용되는 JWT는 Token의 변조를 감지할 수 있도록 하여 Token이 변조되었을 경우, 해당 토큰을 통한 요청을 응답하지 않도록 할 수 있습니다.
    - 토큰 탈취에 대한 방안으로 짧은 유효 기한의 Access Token과 긴 유효 기한의 Refresh Token을 사용합니다. refresh token을 통해 access token을 생성하고, refresh token은 서버 쪽에 저장하고 access token을 통해 통신하도록 합니다.
    - 출처
        - [https://mangkyu.tistory.com/55](https://mangkyu.tistory.com/55)

## HTTP request 메세지에 담기는 메소드는 어떤 것이 있으며, 그 특정이 무엇인가요?

## *사용자의 로그인을 위한 요청을 보낼 때 , 어떤 request method를 이용할까요?

POST 입니다.

## 왜 사용자에게 로그인 요청 시, GET을 이용해 요청하지 않는 이유는 무엇인가요?

GET method는 body를 이용하지 않기때문에 로그인 요청 시, 로그인 정보가 유출될 위험이 있습니다.

## REST API는 무엇인가요?

REST를 기반으로 하는 서비스 API를 구축한 것입니다.

## ^REST의 정의와 구성 및 그 특성을 말해주실 수 있으신가요?

REST란 HTTP URI를 통해 해당 자원을 명시하고, HTTP Method를 통해 해당 자원에 대한 처리방법을 정의하는 것입니다. 

### 구성

- 자원
- 매소드
- 표현

### 특징

- server-client
- stateless(무싱테)
- cacheable(캐시 처리 기능)
- layered system(계층화)
- code-on-demand
- uniform interface
- 참조
    
    [[Network] REST란? REST API란? RESTful이란? - Heee's Development Blog](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)
    

## HTTP와 HTTPS는 어떤 차이가 있을까요?

## *일반적인 상식으로는 개인키로 암호화하고, 누구에게나 공개되어있는 공개키로 복호화하는 방식이 납득이 안되잖아요. 그렇다면, 이러한 암호화 방식은 어떨 때 쓰이고 왜 쓰이는지 알고 계신가요?

## *SSL/TLS 통신 과정을 설명하세요.

## CORS 에러가 발생하는 원인을 SOP와 관련하여 설명해주세요.

- SOP는 한 Origin으로부터 로드된 doc또는 script가 다른 Origin의 리소스와 상호 작용하는 방법을 제한하는 보안 매커니즘입니다. 
- CORS 정책은 상호 작용을 허용하는 Origin을 지정하여 다른 Origin과의 상호 작용이 필요한 경우 사용할 수 있도록 합니다.
- CORS 에러는 **SOP를 위반한 상황에서 Origin이 CORS 정책에서 허용되지 않았을 때 발생하는 에러**입니다.

- 출처
    - [https://www.youtube.com/watch?v=6QV_JpabO7g&t=5s](https://www.youtube.com/watch?v=6QV_JpabO7g&t=5s)

## CORS 동작 방법들에 대해 설명해주세요.

1. Preflight Request
    1. OPTIONS 메서드를 통해 다른 도메인의 리소스 요청이 가능한지 확인합니다.
    2. 요청이 가능하다면 실제 요청을 보냅니다.
    3. 서버 측에서 허가한 다른 출처의 도메인과 해당 도메인에게 허가된 메서드 등을 응답합니다.
2. Simple Request
    1. 요청을 보내는 즉시 cross origin인지 확인합니다.
3. Credentialed Request
    1. 인증 관련 헤더를 포함할 때 사용하는 요청합니다.
    2. 브라우저가 제공하는 XMLHttpRequest 객체나 fetch API는 별도의 옵션 없이 쿠키 정보나 인증과 관련된 헤더를 기본적으로 요청에 담지 않으므로, credentials 옵션을 변경하지 않고서는 cookie를 주고받을 수 없습니다.
- 출처
    - [https://ingg.dev/cors/](https://ingg.dev/cors/)

## CSRF(Cross Site Request Forgery) 에 대해 알고 있나요?

- 브라우저 내의 인증 정보를 이용하여 사용자의 의지와 무관하게 공격자가 의도한 행위를 특정 웹 사이트에 요청하게 하는 공격입니다.
- 출처
    -[https://www.youtube.com/watch?v=Q3YuKipzPbs](https://www.youtube.com/watch?v=Q3YuKipzPbs)

## XSS(Cross-Site Scription) 에 대해 알고 있나요?

- 사용자가 값을 입력할 수 있는 웹 페이지를 통해 웹 사이트 내에 악성 스크립트를 삽입할 수 있는 취약점입니다.

## CORS 에러의 해결 방법에 대해 이야기해주세요.

- 프록시 서버에서 중간에 자신의 origin과 요청하는 origin을 동일하게 바꿉니다.
- 다른 해결 방법으로는 Access-Control-Allow-Origin를 사용하여 Origin을 추가해줍니다.

1. Java에서 CORS 에러를 해결하는 방법에 대해 알고 있나요?
- 출처
    - [https://abbo.tistory.com/147](https://abbo.tistory.com/147)
    - [https://wonit.tistory.com/572](https://wonit.tistory.com/572)

## 모바일에서 나타나는 CORS 에러에 대해 알고 있으신 분 계신가요?

- CORS의 중요한 점은 한 Origin에서 로드된 웹 페이지가 다른 Origin에서 데이터를 수정하는 AJAX 요청이나 HTTP 요청을 방지하는 것입니다. 기본 모바일 앱은 한 Origin에서 로드된 웹 페이지가 아니므로 CORS 제한이 필요하거나 적용되지 않습니다.
- 다만, 하이브리드 앱의 경우 WebView를 사용하는 과정에서 Options 메소드를 통해 CORS 에러의 유효성을 검사하여 CORS 에러에 방지해야 합니다.
- 출처
    - [https://pythonq.com/so/android/865501](https://pythonq.com/so/android/865501)
    - [https://stackoverflow.com/questions/47239244/no-cors-needed-for-mobile-apps](https://stackoverflow.com/questions/47239244/no-cors-needed-for-mobile-apps)

## `HTTP/1.1`과 `HTTP/2.0`의 차이점에 대해 설명해주세요.

- HTTP/1.1은 connection당 하나의 요청을 처리하도록 설계되어 있습니다. 동시 전송이 불가능하고 요청과 응답이 순차적으로 이루어지게 됩니다. 그렇기 때문에 요청할 리소스의 개수에 비례하여 대기 시간이 길어지게 됩니다.
- HTTP/2.0은 HTTP/1.X 버전의 성능 향상을 위해 확장한 것입니다. HTTP/1.X 버전과의 가장 큰 차이점은 메시지 전송 방식을 변경시킨 것입니다.
- 출처
    - [https://www.youtube.com/watch?v=ZgSC5K1sUYM](https://www.youtube.com/watch?v=ZgSC5K1sUYM)
    - [https://www.youtube.com/watch?v=xcrjamphIp4](https://www.youtube.com/watch?v=xcrjamphIp4)
    - [https://github.com/brave-people/brave-tech-interview/blob/main/contents/network.md](https://github.com/brave-people/brave-tech-interview/blob/main/contents/network.md)

## WAS와 WS의 차이점은 무엇인가요?

- Web Server는 정적인 컨텐츠를 제공할 수 있습니다.
- Web Application Server는 Web Server가 제공하는 모든 기능을 지원하고, 추가적으로 애플리케이션 수준의 동적인 컨텐츠를 제공할 수 있습니다.
- 출처
    - [https://goldsony.tistory.com/37](https://goldsony.tistory.com/37)
    - [https://stackoverflow.com/questions/936197/what-is-the-difference-between-application-server-and-web-server](https://stackoverflow.com/questions/936197/what-is-the-difference-between-application-server-and-web-server)
    - [https://www.ibm.com/cloud/learn/web-server-vs-application-server](https://www.ibm.com/cloud/learn/web-server-vs-application-server)

## *Apache와 Nginx를 사용해보았다면, 어떤 이유로 사용했나요?

## *WAS에서 대표적으로 사용되는 Apache와 Nginx의 차이점은 무엇인가요?

- Apache는 요청이 들어오면 새로운 프로세스 혹은 스레드를 생성합니다.
- Nginx는 Apache의 C10K 문제점을 해결하기 위해 만들어진 Event-Driven 구조의 웹 서버로서 서버로 들어오는 요청을 event로 처리하여 cpu 소모가 비교적 적습니다.

- 출처
    - [https://www.youtube.com/watch?v=6FAwAXXj5N0](https://www.youtube.com/watch?v=6FAwAXXj5N0)

## 웹 브라우저에 구글 도메인 주소 입력하면 어떤 일이 일어나나요?

- URL을 파싱하여 규칙에 따라 의미를 조사합니다.
- 검색된 문자열이 URL이라면 HSTS 리스트를 점검합니다.
- HSTS 리스트에 있다면 HTTPS 프로토콜로 요청을 전달합니다.
- HSTS 리스트에 없다면 HTTP 프로토콜로 요청을 전달합니다.
- 브라우저 내의 캐시에 도메인이 존재하는지 확인합니다.
- 브라우저 내에 없다면 로컬내의 hosts 파일에 존재하는지 확인합니다.
- 로컬 라우터나 ISP의 캐시 DNS 서버에 IP 주소 조회를 요청합니다.
    - ISP에 IP가 존재하지 않으면,
    - 해당 도메인과 같은 네크워크를 공유하는 DNS는 ARP 프로세스를 통해 IP 주소를 검색합니다.
- 브라우저가 해당 도메인의 IP 주소를 받으면, 호스트 명과 포트번호를 가지고 TCP 소켓을 요청합니다.
- 전송 계층에서는 헤더에 목적지 포트, 출발지 포트를 추가한다.
- 네트워크 계층에서는 헤더에 IP 주소를 추가한다.
- LAN으로 넘겨진 데이터는 Switch, Router를 거쳐 서버의 LAN에 도착한다.
- 서버에 도착하면 클라이언트와 통신하기 위해 TCP 연결을 진행한다.
- 서버가 사용자의 요청을 받으면 캐시 서버에 해당 요청이 있는지 확인한다.
- 캐시 서버에 해당 요청이 없으면 요청 메시지에 따른 데이터를 응답 메시지에 넣어 HTTP Response로 전송한다.
- 브라우저는 응답받은 메시지를 캐시에 저장하고 사용자에게 보여준다.
- 출처
    - [https://github.com/SantonyChoi/what-happens-when-KR#url](https://github.com/SantonyChoi/what-happens-when-KR#url)