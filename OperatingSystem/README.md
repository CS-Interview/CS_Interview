 

1. 프로세스가 무엇인지 그리고 프로세스의 4가지 구성요소에 대해 알려주세요

   프로세스란 간단히 말해서 컴퓨터에서 실행되고 있는 프로그램을 뜻합니다. 프로그램을 실행시키면 OS는 디스크에 있던 프로그램 파일을 찾아서 메모리에 적재(load)하고 프로세스를 만듭니다.

   프로세스는 코드(code), 전역변수들을 저장하는 데이터(data), 지역변수와 함수의 매개변수를 저장하는 스택(stack), 그리고 동적 메모리를 할당하는 힙(heap) 으로 구성되어있습니다.

2. 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

   프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능합니다. 또한, 프로세스 간의 통신 (IPC)보다 스레드 간의 통신 비용이 적기 때문입니다.

   대신 멀티 스레드 사용 시 공유 자원으로 인한 문제 해결을 위해 동기화에 신경써야 합니다.

3. Stack 영역만 스레드마다 따로 할당되는 이유는?

   Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함입니다.

4. Context Switching 과정을 PCB와 연관시켜 설명하시오.

   컨텍스트 스위칭이란 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정입니다.

   1)  인터럽트가 발생하면 현재 진행되고 있는 프로세스의 상태 (Context)를 PCB에 저장합니다.

   2)  다음에 실행할 프로세스를 동작시켜 작업을 처리합니다.

   3)  PCB에 저장되었던 프로세스 상태를 복구하여 마저 처리합니다.

5. 뮤텍스와 세마포어의 차이점에 대해 설명하시오.

   뮤텍스는 Locking 메커니즘으로, 락을 건 쓰레드만이 임계 영역을 나갈 때 락 해제가 가능합니다.

   세마포어는 Signaling 메커니즘으로, 락을 걸지 않은 쓰레드도 sinal을 사용하여 락 해제가 가능합니다.

   세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없습니다. 세마포어 카운트를 1로 설정 시 뮤텍스처럼 사용 가능합니다.

6. 교착상태의 뜻과 발생 조건에 대해 설명하시오.

   교착상태란 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황으로 프로세스가 자원을 얻기 위해 영구적으로 기다리는 상태입니다.

   1)  Mutual Exclusion 상호배제 : 한 자원은 한번에 한 프로세스만 사용 가능

   2)  Hold and Wait 점유 대기: 프로세스는 자원이 할당된 상태에서 다른 자원이 할당되기를 기다린다.

   3)  No preemption 비선점 : 다른 프로세스가 사용 중인 자원을 선점하여 사용할 수 없다.

   4)  Circular Wait 환형 대기: 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.

7. 교착상태를 회피하는 방법중 하나인 은행가 알고리즘에 대하여 설명해 주세요.

   다익스트라가 제안한 기법으로, 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, 모든 자원 형태들의 최대수를 선언하여 이 할당량으로 시뮬레이션을 해서 안정 상태(Safe state)에 들 수 있는지 여부를 검사합니다. 이때 안정상태에 있으면 자원을 할당하고, 그렇지 않으면 다른 프로세스들이 자원을 해제할 때 까지 프로세스를 대기시킵니다.

8. 기아 상태의 뜻과 해결책에 대해 설명하시오.

   기아 상태란 프로세스의 우선 순위가 낮아서 원하는 자원을 할당 받지 못하는 상태입니다. 

   기아상태를 해결하기 위한 Aging 기법은 시스템에서 자원을 기다린 시간에 비례하여 프로세스에게 우선 순위를 부여하는 방법입니다. 

9. 기아 상태가 발생할 수 있는 CPU 스케쥴링 기법과 해결책을 도입한 스케줄링 기법을 한가지씩 설명하시오.

   SJF(Shortest - Job - First) 기법은 CPU 사용이 짧은 job을 선호하기 때문에 사용 시간이 긴 프로세스는 거의 영원히 CPU를 할당 받을 수 없어 기아 상태가 발생할 수 있습니다.

   SJF의 기아 문제를 해결한 방법이 HRN으로 cpu 사용시간과 더불어 대기시간을 고려하여 cpu할당합니다.

   우선순위 (priority) : 각 프로세스의 우선순위를 정해서 우선순위 번호를 각 프로세스에게 부여하고 우선순위가 높은 프로세스에게 CPU를 할당하는 방법, 우선순위가 낮은 프로세스는 거의 영원히 CPU를 할당 받을 수 없어 기아 상태가 발생할 수 있습니다. -> 에이징 기법으로 해결가능

10. 다단계 큐와 다단계 피드백 큐의 차이점을 설명하시오.

    다단계 큐(MQ: Multi-level Queue) : 프로세스 특성별로 준비 큐를 여러 개 두어 우선순위를 부여하고, 높은 우선순위 큐들이 모두 비었을 때만 다음 단계의 낮은 우선순위의 큐 프로세스들에게 CPU를 할당하는 방법 -> 고정된 우선순위의 선점식 스케쥴링

    다단계 피드백 큐(MFQ: Multi-level Feedback Queue) : 다단계 큐와 같지만, 프로세스들이 큐 사이를 이동함, cpu를 많이 사용하는 프로세스는 낮은 우선순위 큐로 이동시키고 낮은 우선순위의 큐에서 오래대기하는 프로세스들은 높은 우선순위 큐로 이동시킴. -> 가변식 우선순위 선점식 스케쥴링

11. 링커와 로더의 차이점은?

    링커는 소스코드의 실행 가능한 모듈을 생성하고 로더는 모듈을 메모리에 로드합니다. (프로그램의 전부 또는 일부를 메모리에 적재합니다.).

12. Swapping의 뜻과 사용 이유를 설명하시오.

    스와핑은 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 보내고 다른 프로세스의 메모리를 불러 들이는 메모리 관리 기법입니다. 주 기억 장치로 불러오는 과정을 Swap-in, 보조 기억 장치로 내보다는 과정을 Swap-out이라고 합니다.

    스와핑은 메모리에 존재하는 프로세스의 수, 즉 다중 프로그래밍의 정도를 조절합니다. 너무 많은 프로그램이 메모리에 동시에 올라오면 프로세스당 할당되는 메모리 양이 적어져 시스템 전체의 성능이 크게 떨어지기 때문에 스와핑을 통해 몇몇 프로그램을 디스크의 스왑 영역으로 보냅니다.

13. 메모리 단편화의 종류와 해결 방법에 대해 차이점 위주로 설명하시오.

    단편화는 기억 장치의 빈공간이 여러 조각으로 나뉘는 현상으로, 외부 단편화와 내부 단편화가 있습니다. 

    외부 단편화는 행할 작업보다 많은 메모리 공간이 남아있지만 배치할 수 없는 경우로 메모리 배치에 따라 발생하는 문제입니다. 페이징으로 해결하거나 통합과 압축 등으로 해결할 수 있습니다.

    내부 단편화는 업에 필요한 공간보다 많은 공간을 할당받아서 내부의 사용 불가능한 공간이 발생하는 것으로 세그먼트로 해결할 수 있습니다.

- 13-1) 외부 단편화 해결책으로 꼽히는 통합과 압축에 대해 설명하고 차이점을 논하시오. 

  통합은 빈 공간들의 주소가 인접한 경우 통합하여 매우 작은 공간들이 여러 개 발생하는 것을 막는 방법입니다.

  압축은 모든 빈 공간들을 한 곳으로 합쳐 하나의 빈 영역으로 생성하는 방법입니다.

  통합은 연속된 공간들을 합병하지만 압축은 재배치를 통해 비연속적으로 흩어져 있는 공간들을 합병합니다. 따라서 압축 기법은 단편화를 없애는 좋은 방법이 될 수 있지만 비용이 크기 때문에 비경제적입니다.

14. 페이지 부재 처리 과정을 설명하시오.

    1)  CPU가 무효 페이지에 접근하면 MMU는 페이지 부재 트랩 (page fault trap)을 발생시키며 CPU 제어권이 커널 모드로 전환됩니다.

    2)  커널 모드에서 page fault handler가 호출되며, 이때 호출된 페이지가 invalid한 경우 (잘못된 주소를 가지거나 잘못된 접근인 경우)에는 프로세스가 종료됩니다.

    3)  i. Valid한 페이지일 경우 물리적 메모리에 비어있는 프레임 (free frame)을 할당받아 그 공간에 해당 페이지를 읽어옵니다.

    ​	ii. 비어있는 프레임이 없다면 페이지 하나를 디스크로 스왑 아웃 시킨 후 페이지를 읽어옵니다.

    4)  요청된 페이지가 디스크로부터 메모리로 적재되기 까지, 페이지 폴트를 발생시킨 프로세스는 PCB에 CPU 레지스터 상태 및 프로그램 카운터값을 저장해둔 후 CPU를 빼앗기고 block됩니다.  

    5)  디스크 입출력이 완료되어 인터럽트가 발생하면 페이지테이블에서 해당 페이지로의 유효-무효 비트를 유효로 변경하고 block해뒀던 프로세스를 ready queue로 이동시킵니다.

    6)  이 프로세스가 다시 CPU를 할당받으면 PCB에 저장해둔 값을 복원시켜 중단되었던 명령부터 실행됩니다.

15. 스레싱의 뜻과 원인에 대해 설명하시오. 

    스레싱이란 메모리 영역에 접근할 때 페이지폴트율이 높아 성능이 저하되는 상태입니다. 스레싱은 다중 프로그래밍 정도가 높거나 효율적이지 못한 페이지 교체 방법을 사용할 경우 발생합니다.

- 15-1. 스레싱의 해결 방법을 운영체제 관점에서 설명하시오.

  스레싱을 해결하기 위한 방법으로는 워킹셋 모델과 PFF 등이 있습니다.

  워킹셋 모델이란 지역성을 기반으로 가장 많이 쓰이는 페이지 집합을 메모리 공간에 계속 상주시켜 스레싱을 줄이는 방법입니다. 

  PFF (Page Fault Frequency)란, 페이지 폴트 빈도를 조절하는 방법으로 페이지폴트가 상한선, 하한선 이내에서 발생하도록 유지하는 방법입니다. 페이지폴트 발생 횟수가 상한선을 초과할 경우 프레임 할당을 늘려주며, 반대로 하한선 미만일 경우엔 프레임을 회수하여 줄여줍니다. 

16. 메모리 풀이란? 

    필요한 메모리 공간을 필요한 크기, 개수만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때만 사용하고 반납하는 기법입니다. 

    미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않으며, 필요한 크기 만큼 할당하기 때문에 내부 단편화가 발생하지 않습니다. 메모리 할당, 해제가 잦은 경우에 효과적이나, 사용하지 않는 순간에도 할당되어 있기 때문에 메모리 누수가 발생합니다. 또한 메모리가 메모리 낭비량보다 커졌을 때는 단점이 됩니다.

17. 스케줄러 종류 세 가지에 대해 설명하시오.

    A.   장기 스케줄러 (잡 스케줄러) : 프로세스가 한꺼번에 많이 올라올 시, 메모리와 디스크 사이에서 메모리에, Ready Queue에 어떤 걸 집어넣을지 결정합니다.

    B.   단기 스케줄러 (CPU 스케줄러) : CPU와 메모리 사이에서 Ready Queue에 있는 프로세스 중 어떤 것을 CPU 할당을 받게 할지 스케줄링합니다.

    C.   중기 스케줄러 (Swapper) : 여유공간 부족 시 공간을 만들기 위해 메모리에서 쫓아내어 디스크로 옮겨 동시에 메모리가 많이 올라가는 것을 조절합니다.

18. Process State 종류들에 대해 설명하시오.

    new (생성) : 프로세스의 작업 공간인 메인 메모리에 생성되고 운영 체제 내부에 PCB가 만들어진다. (PCB는 프로세스 실행 정보를 관리하기 위해 생성됩니다.)

    ready(준비) : 프로세서에(CPU)게 할당 받기를 기다립니다.

    running : 프로세서를 점유하여 명령어들이 실행됩니다.

    waiting (대기) : 이벤트 (I/O 종료 등 외부 신호)가 일어나길 기다립니다.

    terminated : 프로세스 수행이 끝난다. 할당된 자원을 OS에 돌려주고 관련 PCB가 삭제된다.